#include "text5x7.h"
#include <string.h>

// 5x7 font, each char = 5 bytes, LSB is top pixel. One blank column we add as spacing in code.
// Range: ASCII 0x20..0x7E (95 chars)
static const uint8_t font5x7[95][5] = {
  {0x00,0x00,0x00,0x00,0x00}, {0x00,0x00,0x5F,0x00,0x00}, {0x00,0x07,0x00,0x07,0x00},
  {0x14,0x7F,0x14,0x7F,0x14}, {0x24,0x2A,0x7F,0x2A,0x12}, {0x23,0x13,0x08,0x64,0x62},
  {0x36,0x49,0x55,0x22,0x50}, {0x00,0x05,0x03,0x00,0x00}, {0x00,0x1C,0x22,0x41,0x00},
  {0x00,0x41,0x22,0x1C,0x00}, {0x14,0x08,0x3E,0x08,0x14}, {0x08,0x08,0x3E,0x08,0x08},
  {0x00,0x50,0x30,0x00,0x00}, {0x08,0x08,0x08,0x08,0x08}, {0x00,0x60,0x60,0x00,0x00},
  {0x20,0x10,0x08,0x04,0x02}, {0x3E,0x51,0x49,0x45,0x3E}, {0x00,0x42,0x7F,0x40,0x00},
  {0x42,0x61,0x51,0x49,0x46}, {0x21,0x41,0x45,0x4B,0x31}, {0x18,0x14,0x12,0x7F,0x10},
  {0x27,0x45,0x45,0x45,0x39}, {0x3C,0x4A,0x49,0x49,0x30}, {0x01,0x71,0x09,0x05,0x03},
  {0x36,0x49,0x49,0x49,0x36}, {0x06,0x49,0x49,0x29,0x1E}, {0x00,0x36,0x36,0x00,0x00},
  {0x00,0x56,0x36,0x00,0x00}, {0x08,0x14,0x22,0x41,0x00}, {0x14,0x14,0x14,0x14,0x14},
  {0x00,0x41,0x22,0x14,0x08}, {0x02,0x01,0x51,0x09,0x06}, {0x32,0x49,0x79,0x41,0x3E},
  {0x7E,0x11,0x11,0x11,0x7E}, {0x7F,0x49,0x49,0x49,0x36}, {0x3E,0x41,0x41,0x41,0x22},
  {0x7F,0x41,0x41,0x22,0x1C}, {0x7F,0x49,0x49,0x49,0x41}, {0x7F,0x09,0x09,0x09,0x01},
  {0x3E,0x41,0x49,0x49,0x7A}, {0x7F,0x08,0x08,0x08,0x7F}, {0x00,0x41,0x7F,0x41,0x00},
  {0x20,0x40,0x41,0x3F,0x01}, {0x7F,0x08,0x14,0x22,0x41}, {0x7F,0x40,0x40,0x40,0x40},
  {0x7F,0x02,0x0C,0x02,0x7F}, {0x7F,0x04,0x08,0x10,0x7F}, {0x3E,0x41,0x41,0x41,0x3E},
  {0x7F,0x09,0x09,0x09,0x06}, {0x3E,0x41,0x51,0x21,0x5E}, {0x7F,0x09,0x19,0x29,0x46},
  {0x46,0x49,0x49,0x49,0x31}, {0x01,0x01,0x7F,0x01,0x01}, {0x3F,0x40,0x40,0x40,0x3F},
  {0x1F,0x20,0x40,0x20,0x1F}, {0x3F,0x40,0x38,0x40,0x3F}, {0x63,0x14,0x08,0x14,0x63},
  {0x07,0x08,0x70,0x08,0x07}, {0x61,0x51,0x49,0x45,0x43}, {0x00,0x7F,0x41,0x41,0x00},
  {0x02,0x04,0x08,0x10,0x20}, {0x00,0x41,0x41,0x7F,0x00}, {0x04,0x02,0x01,0x02,0x04},
  {0x40,0x40,0x40,0x40,0x40}, {0x00,0x01,0x02,0x04,0x00}, {0x20,0x54,0x54,0x54,0x78},
  {0x7F,0x48,0x44,0x44,0x38}, {0x38,0x44,0x44,0x44,0x20}, {0x38,0x44,0x44,0x48,0x7F},
  {0x38,0x54,0x54,0x54,0x18}, {0x08,0x7E,0x09,0x01,0x02}, {0x0C,0x52,0x52,0x52,0x3E},
  {0x7F,0x08,0x04,0x04,0x78}, {0x00,0x44,0x7D,0x40,0x00}, {0x20,0x40,0x44,0x3D,0x00},
  {0x7F,0x10,0x28,0x44,0x00}, {0x00,0x41,0x7F,0x40,0x00}, {0x7C,0x04,0x18,0x04,0x78},
  {0x7C,0x08,0x04,0x04,0x78}, {0x38,0x44,0x44,0x44,0x38}, {0x7C,0x14,0x14,0x14,0x08},
  {0x08,0x14,0x14,0x14,0x7C}, {0x7C,0x08,0x04,0x04,0x08}, {0x48,0x54,0x54,0x54,0x20},
  {0x04,0x3F,0x44,0x40,0x20}, {0x3C,0x40,0x40,0x20,0x7C}, {0x1C,0x20,0x40,0x20,0x1C},
  {0x3C,0x40,0x30,0x40,0x3C}, {0x44,0x28,0x10,0x28,0x44}, {0x0C,0x50,0x50,0x50,0x3C},
  {0x44,0x64,0x54,0x4C,0x44}, {0x00,0x08,0x36,0x41,0x00}, {0x00,0x00,0x7F,0x00,0x00},
  {0x00,0x41,0x36,0x08,0x00}, {0x10,0x08,0x08,0x10,0x08},
};

void txt_init(txt_cfg_t *t){
    t->x = 0; t->y = 0; t->scale = 1; t->wrap = 1; t->color = TXT_ON;
}
void txt_set_cursor(txt_cfg_t *t, uint8_t x, uint8_t y){ t->x = x; t->y = y; }
void txt_set_scale (txt_cfg_t *t, uint8_t s){ if (s==0) s=1; t->scale = s; }
void txt_set_wrap  (txt_cfg_t *t, uint8_t w){ t->wrap = w ? 1 : 0; }
void txt_set_color (txt_cfg_t *t, txt_color_t c){ t->color = c; }

static void draw_pixel_scaled(ssd1306_t *dev, uint8_t x, uint8_t y, uint8_t s, txt_color_t c){
    for (uint8_t dy=0; dy<s; ++dy){
        for (uint8_t dx=0; dx<s; ++dx){
            switch (c){
                case TXT_ON:  ssd1306_pixel(dev, x+dx, y+dy, 1); break;
                case TXT_OFF: ssd1306_pixel(dev, x+dx, y+dy, 0); break;
                case TXT_INV: {
                    // read-modify: toggle; here we approximate by XOR: read is not available, so we flip by writing both ways
                    // Instead, implement INV by drawing ON if currently OFF and OFF if currently ON would require a getter.
                    // Simple approach: draw a 1 then 0 quickly won't help. We'll emulate INV by ON for foreground and later
                    // caller can fill background if needed. To truly invert, pre-fill a box then draw with TXT_OFF for background.
                    ssd1306_pixel(dev, x+dx, y+dy, 1);
                } break;
            }
        }
    }
}

uint8_t ssd1306_drawChar(ssd1306_t *dev, txt_cfg_t *t, char c){
    if (c == '\r') return 0;
    if (c == '\n'){
        t->x = 0;
        t->y = (uint8_t)(t->y + (8 * t->scale));  // 7px font + 1px spacing
        return 0;
    }
    if (c < 32 || c > 126) c = '?';
    const uint8_t *glyph = font5x7[c - 32];

    uint8_t char_w = (uint8_t)(6 * t->scale); // 5 columns + 1 spacing
    uint8_t char_h = (uint8_t)(8 * t->scale); // 7 rows + 1 spacing

    // Wrap if requested
    if (t->wrap && (t->x + char_w) > SSD1306_WIDTH){
        t->x = 0;
        t->y = (uint8_t)(t->y + char_h);
    }
    if (t->x >= SSD1306_WIDTH || t->y >= SSD1306_HEIGHT) return 0;

    // Draw 5 columns
    for (uint8_t col=0; col<5; ++col){
        uint8_t bits = glyph[col];
        for (uint8_t row=0; row<7; ++row){
            if (bits & (1U<<row)){
                draw_pixel_scaled(dev, (uint8_t)(t->x + col * t->scale),
                                       (uint8_t)(t->y + row * t->scale),
                                       t->scale, t->color);
            } else if (t->color == TXT_OFF){
                // If drawing "background", clear off pixels
                draw_pixel_scaled(dev, (uint8_t)(t->x + col * t->scale),
                                       (uint8_t)(t->y + row * t->scale),
                                       t->scale, TXT_OFF);
            }
        }
    }
    // 1 column spacing
    if (t->color == TXT_OFF){
        for (uint8_t row=0; row<7; ++row){
            draw_pixel_scaled(dev, (uint8_t)(t->x + 5 * t->scale),
                                   (uint8_t)(t->y + row * t->scale),
                                   t->scale, TXT_OFF);
        }
    }

    t->x = (uint8_t)(t->x + char_w);
    return char_w;
}

uint16_t ssd1306_drawText(ssd1306_t *dev, txt_cfg_t *t, const char *s){
    uint16_t px = 0;
    while (*s){
        px += ssd1306_drawChar(dev, t, *s++);
    }
    return px;
}

int ssd1306_printf(ssd1306_t *dev, txt_cfg_t *t, const char *fmt, ...){
    char buf[128]; // keep stack small; print in chunks if needed
    va_list ap;
    va_start(ap, fmt);
    int n = vsnprintf(buf, sizeof(buf), fmt, ap);
    va_end(ap);
    if (n < 0) return n;
    // If longer than buf, print what we have; caller can call again for more
    ssd1306_drawText(dev, t, buf);
    return n;
}
